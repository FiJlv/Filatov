Завдання 1

1. Single Responsibility Principle
Клас повинен відповідати за одну задачу і ця відповідальність має бути повністю інкапсульована.

Є клас користувач, який має ім'я та пароль. Припустимо є задача додати можливість збереження користувача до бд. Можна додати метод який цим займається, але він до цього класу не відноситься i додавання iнших методiв в майбутньому приведе до розростання цього класу. Правильніше одразу винести функціонал у відповідні класи, які вирішують конкретні задачi. Тобто, у випадку з бд створити клас репозиторiй, у якому є метод збереження користувача. 

2. Open Closed Principle
Програмні сутності повинні бути відкриті для розширення, але закриті для модифікації.

Є клас інструмент, з полями тип і швидкість роботи, далі є клас користувач який приймає інструмент. Створюємо інструмент пила, задаємо швидкість, потім створюємо користувача і передаємо пилу. Для того щоб використовувати пилу, в класі інструмент створюємо метод роботи, після чого делегуємо в користувача і викликаємо в нього. Для додавання нового інструменту, наприклад ножиць, доведеться змінювати метод роботи, порушуючи цей принцип, так як ми його модифікуємо. Потрібно винести метод роботи в інтерфейс роботи і реалізувати його в інструменті. Потім вже створюємо конкретні сутності(пила, ножиці), які успадковуються від класу інструмент і вже в них задається логіка. Щоб додати новий інструмент, потрібно створити клас і успадкувати його від базового класу. У результаті, дотримуючись цього принципу при додаванні нового функціоналу замість зміни вже розробленої реалізації програмної сутності необхідно створювати новий клас.   

3. Liskov Substitution Principle
Куди приходить базовий тип, туди без жодних проблем має приходити його підтип.

Уявiмо у нас є клас тварин з методами їсти і спати, далі є клас наслiдник птах, до якого додається метод літати, після створюємо конкретні сутності орел, голуб, пінгвін, якi успадковуються від классу птах. У класу пінгвіна спосіб літати не працює, тобто тут порушується цей принцип.

4. Interface Segregation Principle
Надто товсті інтерфейси необхідно розділяти на більш маленькі та специфічні, щоб програмні сутності маленьких інтерфейсів знали тільки про методи, які необхідні їм у роботі.

Візьмемо попередній приклад, тільки замість класу птиці буде інтерфейс із методами літати та плавати. Імплементуємо інтерфейс у кожну сутність та реалізуючи методи розуміємо, що правильніше буде розбити інтерфейс на два, кожен з яких відповідає за одну дію, адже орел та голуб не вмiють плавати, як i пiнгвiн лiтати. 

5. Dependency Inversion Principle
Абстракції не повинні залежати від деталей. Деталі мають залежати від абстракцій.

Уявiмо два класи:
1)ConsolePrinter з методом Print, який виводить передану строку.
2)Book з властивостями string Text, ConsolePrinter Printer і методом Print де ми через Printer викликаємо метод першого класу.
За допомогою ConsolePrinter клас Book друкує текст, тим самим залежить від нього, також жорстко визначено, що книгу можна друкувати лише за допомогою цього класу. Дотримуючись цього принципу, потрібно створити інтерфейс IPrinter з методом Print й використовувати його в Book замiсть ConsolePrinter, тим самим відокремивши абстракцію від конкретних реалізацій. У результаті Book і ConsolePrinter залежить від абстракції IPrinter.

Завдання 2 

Площа прямокутника дорівнює добутку висоти та ширини. Уявiмо у нас є метод, який тестує правильність площі (висота 2 * ширина 4 = площа 8). Якщо туди потрапить квадрат, у якому висота і ширина рівні, то програма видасть помилку. Відповідно, принцип Лісков порушується.